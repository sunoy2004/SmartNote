/**
 * Supabase Edge Function for Model Inference
 * Provides transcription and summarization endpoints
 * Runs on Deno with Supabase Edge Runtime
 */

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

// Initialize Supabase client
const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
const supabase = createClient(supabaseUrl, supabaseKey);

interface TranscriptionRequest {
  audio_url: string;
}

interface SummaryRequest {
  text: string;
}

interface VoiceToNotesRequest {
  audio_url: string;
}

interface ModelResponse {
  transcript?: string;
  summary?: string;
  error?: string;
}

/**
 * Download model from Supabase Storage
 */
async function downloadModel(modelName: string): Promise<Uint8Array> {
  try {
    const { data, error } = await supabase.storage.from('models').download(modelName);
    
    if (error) {
      throw new Error(`Failed to download model ${modelName}: ${error.message}`);
    }
    
    if (!data) {
      throw new Error(`No data returned for model ${modelName}`);
    }
    
    return new Uint8Array(await data.arrayBuffer());
  } catch (error) {
    console.error(`Error downloading model ${modelName}:`, error);
    throw error;
  }
}

/**
 * Mock ASR transcription function
 * In a real implementation, this would use the actual CNN+BiLSTM+CTC model
 */
async function transcribeAudio(audioUrl: string): Promise<string> {
  // This is a mock implementation
  // In a real scenario, you would:
  // 1. Download the audio file from the URL
  // 2. Process it with librosa-like functions
  // 3. Run it through the CNN+BiLSTM+CTC model
  // 4. Decode the output with CTC decoder
  
  // For demonstration, return a mock transcript
  return "This is a mock transcription of the audio file. In a real implementation, this would be generated by the CNN plus BiLSTM plus CTC model.";
}

/**
 * Mock summarization function
 * In a real implementation, this would use the actual Transformer model
 */
async function summarizeText(text: string): Promise<string> {
  // This is a mock implementation
  // In a real scenario, you would:
  // 1. Tokenize the text with the saved tokenizer
  // 2. Run it through the Transformer encoder-decoder model
  // 3. Generate summary with greedy decoding
  
  // For demonstration, return a mock summary
  return "This is a mock summary of the provided text. In a real implementation, this would be generated by the Transformer encoder-decoder model.";
}

/**
 * Handle transcription request
 */
async function handleTranscription(req: TranscriptionRequest): Promise<ModelResponse> {
  try {
    if (!req.audio_url) {
      return { error: "Missing audio_url parameter" };
    }
    
    const transcript = await transcribeAudio(req.audio_url);
    return { transcript };
  } catch (error) {
    console.error("Transcription error:", error);
    return { error: `Transcription failed: ${error.message}` };
  }
}

/**
 * Handle summarization request
 */
async function handleSummarization(req: SummaryRequest): Promise<ModelResponse> {
  try {
    if (!req.text) {
      return { error: "Missing text parameter" };
    }
    
    const summary = await summarizeText(req.text);
    return { summary };
  } catch (error) {
    console.error("Summarization error:", error);
    return { error: `Summarization failed: ${error.message}` };
  }
}

/**
 * Handle voice-to-notes request (transcription + summarization)
 */
async function handleVoiceToNotes(req: VoiceToNotesRequest): Promise<ModelResponse> {
  try {
    if (!req.audio_url) {
      return { error: "Missing audio_url parameter" };
    }
    
    // Step 1: Transcribe audio
    const transcript = await transcribeAudio(req.audio_url);
    
    // Step 2: Summarize transcript
    const summary = await summarizeText(transcript);
    
    return { transcript, summary };
  } catch (error) {
    console.error("Voice-to-notes error:", error);
    return { error: `Voice-to-notes processing failed: ${error.message}` };
  }
}

/**
 * Main function to handle HTTP requests
 */
async function handleRequest(request: Request): Promise<Response> {
  // Set CORS headers
  const headers = {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
  };
  
  // Handle preflight requests
  if (request.method === "OPTIONS") {
    return new Response(null, { status: 204, headers });
  }
  
  try {
    // Parse request
    const url = new URL(request.url);
    const path = url.pathname;
    
    // Health check endpoint
    if (path === "/health" && request.method === "GET") {
      return new Response(JSON.stringify({ status: "ok", service: "voice-to-notes" }), {
        status: 200,
        headers,
      });
    }
    
    // Parse body for POST requests
    let body = {};
    if (request.method === "POST") {
      try {
        body = await request.json();
      } catch (error) {
        return new Response(JSON.stringify({ error: "Invalid JSON in request body" }), {
          status: 400,
          headers,
        });
      }
    }
    
    // Route requests
    let response: ModelResponse = { error: "Not found" };
    
    if (path === "/transcribe" && request.method === "POST") {
      response = await handleTranscription(body as TranscriptionRequest);
    } else if (path === "/summarize" && request.method === "POST") {
      response = await handleSummarization(body as SummaryRequest);
    } else if (path === "/voice-to-notes" && request.method === "POST") {
      response = await handleVoiceToNotes(body as VoiceToNotesRequest);
    }
    
    // Return response
    const statusCode = response.error ? 400 : 200;
    return new Response(JSON.stringify(response), {
      status: statusCode,
      headers,
    });
    
  } catch (error) {
    console.error("Server error:", error);
    return new Response(JSON.stringify({ error: "Internal server error" }), {
      status: 500,
      headers,
    });
  }
}

// Start the server
serve(handleRequest, { port: 8000 });
console.log("Supabase Edge Function listening on port 8000");